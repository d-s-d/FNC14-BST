
\section{Introduction}\label{sec:intro}
Given the simple and recursive structure of a binary search tree, it is easy to
deduce an algorithm to find a specific key in the tree. However, as every binary
search tree can be restructured arbitrarily yielding a new valid binary search
tree holding the same set of keys and, in general, there are great variances
among these tree structures concerning the lookup cost, the "naked"
binary search tree must be accompanied by an algorithm, the sophistication of
which lies in its capability to structure the tree optimally with respect to the
lookup cost.

For dynamic binary search trees, various algorithms have been developed to
balance the tree on inseration and deletion (references). In the case of static
binary search trees, on the other hand, the set of keys is given a priori, along
with a probability distribution that indicates the likeliness of an individual
key being searched for. Based upon this, one can construct an optimal binary
search tree, that is, a search tree which has a minimal expected lookup cost.

In the following we introduce a dynamic programming algorithm, which solves the
problem by examining combinations of optimal subtrees. Our objective then is to
optimally implement this algorithm on a modern Intel-based hardware platform.

Our interest in the algorithm emerges from the fact that the algorithm, in its
bare form, has a straight-forward design which makes its properties apparant:
its runtime is $O(n^3)$, whereas the total memory being accessed is $O(n^2)$.
