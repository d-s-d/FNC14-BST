\section{Optimization}
\mypar{Turn Columns into Rows} Examining the innermost loop, we see that the
the table is accessed row- and column-wise. Thus, the memory is accessed in
strides of $1$ and $n+1$, respectively. However, with two simple changes to the
algorithm, we can avoid strides of $n+1$ and replace them with accesses of
stride $1$: We make use of the lower half of the square table in that we store
newly calculated values not only at $(i,j)$ but also at $(j,i)$. That is,
instead of accessing a column in the upper half, we access a row in the
lower-half. This needs only two minor changes to the algorithm as described in
listing \ref{lst:baseline}: First, line $7$ turns into
\begin{center}
\verb:t = e[IDX(i,r)] + e[IDX(j,r+1)]:, 
\end{center}
and after line $10$, we would insert 
\begin{center}
	\verb:e[IDX(j,i)] = t;:.
\end{center}
\mypar{Bottom-Up} Figure TODO visualizes the order in which the values are
calculated. For each value that is being calculated, a minimum value across

\mypar{Partial Results (Swap innermost loops)}
\mypar{Compressed memory layout}
\mypar{Blocking}
\mypar{Vectorization}
\mypar{Scheduling}
\mypar{Alignment}


